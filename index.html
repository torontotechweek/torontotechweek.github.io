<!DOCTYPE html>
<html>

<head>
	<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
	<script src="https://unpkg.com/maplibre-gl@5.1.0/dist/maplibre-gl.js"></script>
	<link href="https://unpkg.com/maplibre-gl@5.1.0/dist/maplibre-gl.css" rel="stylesheet" />
	<link
		href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap"
		rel="stylesheet">
	<link rel="stylesheet" href="style.css">
</head>

<body>

	<div id="map"></div>
	<div id="category-box"></div>
	<div id="info-box"></div>

	<script>

		const locationFile = 'data/ttw2025_with_buildings.geojson'
		const zoomThreshold = 18
		const imgSource = 'img'
		let currentActiveCategory = 'all';
		let locationData;

		var map = new maplibregl.Map({
			container: 'map',
			style: 'https://torontotechweek.github.io/torontotechweek.json',
			center: [-79.385015, 43.64507],
			zoom: 15,
			minZoom: 11,
			maxZoom: 18,
			//maxBounds: [ [-79.56729275921924, 43.56518035854518],[-79.27118684581397, 43.728046474967954] ],
			bearing: 0,
			pitch: 0,
			pixelRatio: 1,
			hash: true
		});

		map.on('load', async () => {

			// Load points data
			const pointsResponse = await fetch(locationFile);
			const pointsData = await pointsResponse.json();
			locationData = pointsData;

			// Add building source
			map.addSource('toronto_buildings', {
				type: 'vector',
				tiles: ['https://torontotechweek.github.io/data/toronto_buildings/{z}/{x}/{y}.pbf']
			});

			// Add neighborhood source
			map.addSource('toronto_neighborhoods', {
				type: 'vector',
				tiles: ['https://torontotechweek.github.io/data/toronto_neighborhoods/{z}/{x}/{y}.pbf']
			});

			// Add neighborhood centroids
			map.addSource('toronto_neighborhoods_centroids', {
				'type': 'geojson',
				'data': 'data/toronto_neighborhoods_centroids.geojson'
			});

			// Add event source
			map.addSource('events', {
				'type': 'geojson',
				'data': pointsData,
				'cluster': true,
				'clusterRadius': 30,
				'clusterMinPoints': 2,
				'clusterMaxZoom': zoomThreshold
			});

			// Add neighborhood outlines
			map.addLayer({
				'id': 'neighborhoods-outlines',
				'source': 'toronto_neighborhoods',
				'source-layer': 'toronto_neighborhoods',
				'type': 'line',
				'paint': {
					'line-color': 'hsl(20, 50%, 70%)',
					'line-width': ['interpolate', ['linear'], ['zoom'], 10, 1, 18, 10],
					'line-opacity': ['interpolate', ['linear'], ['zoom'], 17, 0.2, 18, 0]
				}
			});

			// Add buildings
			map.addLayer(
				{
					'id': 'buildings',
					'source': 'toronto_buildings',
					'source-layer': 'toronto_buildings',
					'type': 'fill-extrusion',
					'paint': {
						'fill-extrusion-color': 'hsl(25, 20%, 95%)',
						'fill-extrusion-height': [
							'case',
							['!=', ['get', 'max_height'], null], ['get', 'max_height'],
							['!=', ['get', 'avg_height'], null], ['get', 'avg_height'],
							10
						],
						'fill-extrusion-base': 0,
						'fill-extrusion-opacity': ['interpolate', ['linear'], ['zoom'], 15, 0, 16, 0.5, 17, 0.5, 18, 0],
					},
					'minzoom': 15
				}
			);

			// Add neighborhood labels
			map.addLayer({
				id: 'neighborhoods-labels',
				type: 'symbol',
				source: 'toronto_neighborhoods_centroids',
				layout: {
					'text-field': ['get', 'area_name'],
					'text-size': ['interpolate', ['exponential', 1.1], ['zoom'], 10, 1, 18, 50],
					'text-font': ['montserrat-semibold'],
					'text-max-width': 5,
					'text-line-height': 1,
					'text-allow-overlap': true,
					'text-ignore-placement': true,
					//'text-variable-anchor': ['top', 'bottom', 'left', 'right'],
					'text-rotation-alignment': 'viewport',
					'text-pitch-alignment': 'map'
				},
				paint: {
					'text-color': 'hsl(20, 50%, 70%)',
					'text-opacity': 0.8,
				}
			});

			// Add event points
			map.addLayer({
				id: 'points',
				type: 'circle',
				source: 'events',
				filter: ['!', ['has', 'point_count']],
				paint: {
					'circle-radius': 7,
					'circle-color': 'hsl(0, 0%, 0%)',
					'circle-stroke-width': 1.5,
					'circle-stroke-color': 'hsl(0, 0%, 100%)'
				}
			});

			// Add cluster circles
			map.addLayer({
				id: 'clusters',
				type: 'circle',
				source: 'events',
				filter: ['has', 'point_count'],
				paint: {
					'circle-color': [
						'step',
						['get', 'point_count'],
						'hsl(0, 0%, 0%)',
						10, 'hsl(0, 0%, 0%)',
						25, 'hsl(0, 0%, 0%)'
					],
					'circle-radius': [
						'step',
						['get', 'point_count'],
						15,
						10, 20,
						25, 25
					],
					'circle-stroke-width': 1.5,
					'circle-stroke-color': 'hsl(0, 0%, 100%)',
				},
				'maxzoom': zoomThreshold + 1
			});

			// Add cluster count
			map.addLayer({
				id: 'cluster-count',
				type: 'symbol',
				source: 'events',
				filter: ['has', 'point_count'],
				layout: {
					'text-field': '{point_count_abbreviated}',
					'text-font': ['montserrat-semibold'],
					'text-size': 16,
					'text-allow-overlap': true,
					'text-ignore-placement': true
				},
				paint: {
					'text-color': 'hsl(0, 0%, 100%)'
				},
				'maxzoom': zoomThreshold + 1
			});

			map.setLight({
				'anchor': 'viewport',
				'color': 'hsl(0, 0%, 100%)',
				'intensity': 0.5,
				'position': [1.15, 210, 40]
			});

			// Handle clicks on category filter
			document.addEventListener('click', (e) => {
				const categoryFeatureElement = e.target.closest('.category-feature');
				if (!categoryFeatureElement) return;

				const category = categoryFeatureElement.dataset.category;
				if (!category) return;

				// Close any open popup when clicking a category
				if (window.featurePopup) {
					window.featurePopup.remove();
					window.featurePopup = null;
				}

				// Remove all activeCategory classes first
				document.querySelectorAll('.category-feature.activeCategory').forEach(el => {
					el.classList.remove('activeCategory');
				});

				// Toggle logic
				if (currentActiveCategory === category) {
					// Second click on same category - remove filter
					filterLocation('all'); // Show all features
					categoryFeatureElement.classList.remove('activeCategory');
					currentActiveCategory = 'all';
				} else {
					// New category selected
					filterLocation(category);
					categoryFeatureElement.classList.add('activeCategory');
					currentActiveCategory = category;
				}
			});

		});

		const filterLocation = (category) => {
			if (!locationData) return;

			const filtered = {
				...locationData,
				features: category === 'all'
					? locationData.features
					: locationData.features.filter(f => f.properties.start_date_iso?.startsWith(category))
			};

			map.getSource('events').setData(filtered);

			currentActiveCategory = category;
		};

		const createCategoryBox = () => {
			const categoryBox = document.getElementById('category-box');
			categoryBox.innerHTML = '';

			const innerContainer = document.createElement('div');
			innerContainer.className = 'category-box-inner';
			categoryBox.appendChild(innerContainer);

			// Categories
			const categories = [
				{ date: '2025-06-22', day: 'Sun' },
				{ date: '2025-06-23', day: 'Mon' },
				{ date: '2025-06-24', day: 'Tue' },
				{ date: '2025-06-25', day: 'Wed' },
				{ date: '2025-06-26', day: 'Thu' },
				{ date: '2025-06-27', day: 'Fri' },
			];

			categories.forEach(({ date, day }) => {
				const categoryElement = document.createElement('div');
				categoryElement.className = 'category-feature';
				categoryElement.dataset.category = date;

				// Create text span
				const textSpan = document.createElement('p');
				textSpan.textContent = day;

				// Append elements
				categoryElement.appendChild(textSpan);
				innerContainer.appendChild(categoryElement);
			});
		};

		map.on('click', 'points', (e) => {
			const feature = e.features[0];
			const properties = feature.properties;
			const coordinates = e.lngLat;

			// Create popup content container
			const popupContent = document.createElement('div');
			popupContent.className = 'popup-content';

			// Add title
			const title = document.createElement('h1');
			title.className = 'popup-title';
			title.textContent = properties.title || 'Untitled Location';
			popupContent.appendChild(title);

			// Add image if available
			if (properties.image) {
				const imgContainer = document.createElement('div');
				imgContainer.className = 'popup-image-container';
				const img = document.createElement('img');
				img.src = properties.cover;
				img.alt = properties.title || '';
				img.className = 'popup-image';
				imgContainer.appendChild(img);
				popupContent.appendChild(imgContainer);
			}

			// Add description
			if (properties.description) {
				const desc = document.createElement('p');
				desc.className = 'popup-description';
				desc.textContent = properties.description;
				popupContent.appendChild(desc);
			}

			// Create and show popup
			const popup = new maplibregl.Popup({
				closeButton: true,
				closeOnClick: true,
				anchor: 'left'
			})
				.setLngLat(coordinates)
				.setDOMContent(popupContent)
				.addTo(map);
		});

		map.on('click', 'clusters', async (e) => {    
			const clusterFeatures = map.queryRenderedFeatures(e.point, {
    layers: ['clusters'] // Make sure this matches your cluster layer name
});

if (!clusterFeatures.length) {
    console.error('No cluster features found at click point');
    return;
}

const clusterId = clusterFeatures[0].properties.cluster_id;
console.log('Cluster ID:', clusterId);

const features = map.querySourceFeatures('location'); // 'location' is your source ID

// Array to hold all features (including individual features from clusters)
let allFeatures = [];

// Process each feature
for (const feature of features) { 
	if (feature.properties.cluster) {
		// Handle clustered features
		const clusterId = feature.properties.cluster_id;

		try {
			// Get the individual features within the cluster
			const clusterFeatures = await map.getSource('location').getClusterLeaves(
				clusterId,
				Infinity, // Maximum number of points to return
				0 // Offset (for pagination)
			);

			// Add the individual features to the allFeatures array
			allFeatures = allFeatures.concat(clusterFeatures);
		} catch (error) {
			console.error('Error fetching cluster leaves:', error);
		}
	} else {
		return
	}
}


});
		
		map.once('load', () => {
			createCategoryBox();
		});

	</script>
</body>

</html>