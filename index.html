<!DOCTYPE html>
<html>

<head>
	<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
	<meta charset="UTF-8" />
	<script src="https://unpkg.com/maplibre-gl@5.1.0/dist/maplibre-gl.js"></script>
	<link href="https://unpkg.com/maplibre-gl@5.1.0/dist/maplibre-gl.css" rel="stylesheet" />
	<link
		href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap"
		rel="stylesheet">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
	<link rel="stylesheet" href="style.css">
</head>

<body>

	<div class="container">
		<div id="map"></div>
		<div id="info-box"></div>
		<div id="info-box-day"></div>
		<div id="popup-container"></div>
	</div>

	<script>

		const locationFile = 'data/ttw2025_iso.geojson'
		const zoomThreshold = 18
		const imgSource = 'img'
		const featureIds = ['concat', ['get', 'api_id'], '|']
		let currentActiveCategory = 'all';
		let popupOpen = false;
		let locationData;

		var map = new maplibregl.Map({
			container: 'map',
			style: 'torontotechweek.json',
			center: [-79.38709, 43.64909],
			zoom: 12,
			minZoom: 11,
			maxZoom: 18,
			//maxBounds: [ [-79.56729275921924, 43.56518035854518],[-79.27118684581397, 43.728046474967954] ],
			bearing: 0,
			pitch: 20,
			pixelRatio: 1,
			hash: true,
			attributionControl: true
		});

		map.on('load', async () => {

			// Load points data
			const pointsResponse = await fetch(locationFile);
			const pointsData = await pointsResponse.json();
			locationData = pointsData;

			// Add building source
			map.addSource('toronto_buildings', {
				type: 'vector',
				tiles: ['https://torontotechweek.github.io/data/toronto_buildings/{z}/{x}/{y}.pbf']
			});

			// Add neighborhood source
			map.addSource('toronto_neighborhoods', {
				type: 'vector',
				tiles: ['https://torontotechweek.github.io/data/toronto_neighborhoods/{z}/{x}/{y}.pbf']
			});

			// Add neighborhood centroids
			map.addSource('toronto_neighborhoods_centroids', {
				'type': 'geojson',
				'data': 'data/toronto_neighborhoods_centroids.geojson'
			});

			// Add event source
			map.addSource('events', {
				'type': 'geojson',
				'data': pointsData,
				'cluster': true,
				'clusterRadius': 30,
				'clusterMinPoints': 2,
				'clusterMaxZoom': zoomThreshold,
				'clusterProperties': {
					'featureIds': ['concat', featureIds]
				}
			});

			// Add neighborhood outlines
			map.addLayer({
				'id': 'neighborhoods-outlines',
				'source': 'toronto_neighborhoods',
				'source-layer': 'toronto_neighborhoods',
				'type': 'line',
				'paint': {
					'line-color': 'hsl(225, 89%, 90%)',
					'line-width': ['interpolate', ['exponential', 1.5], ['zoom'], 10, 1, 18, 20],
					'line-opacity': ['interpolate', ['linear'], ['zoom'], 10, 0, 11, 0.5, 14, 0.5, 15, 0]
				},
				"minzoom": 10,
				"maxzoom": 15
			});

			// Add building outlines
			map.addLayer({
				'id': 'buildings-outline',
				'source': 'toronto_buildings',
				'source-layer': 'toronto_buildings',
				'type': 'line',
				'paint': {
					'line-color': 'hsl(280, 10%, 40%)',
					'line-width': 2,
					'line-opacity': [ "interpolate", [ "linear" ], [ "zoom" ], 16, 0, 18, 1 ]
				},
				'minzoom': 16
			}, 'highway-name-minor');

			// Add 3d buildings
			map.addLayer({
				'id': 'buildings',
				'source': 'toronto_buildings',
				'source-layer': 'toronto_buildings',
				'type': 'fill-extrusion',
				'paint': {
					'fill-extrusion-color': 'hsl(280, 10%, 40%)',
					'fill-extrusion-height': [
						'case',
						['!=', ['get', 'max_height'], null], ['get', 'max_height'],
						['!=', ['get', 'avg_height'], null], ['get', 'avg_height'],
						10
					],
					'fill-extrusion-base': 0,
					'fill-extrusion-opacity': ['interpolate', ['linear'], ['zoom'], 15, 0, 16, 0.7, 17, 0.7, 18, 0]
				},
				'minzoom': 15
			}, 'highway-name-minor');

			// Add neighborhood labels
			map.addLayer({
				id: 'neighborhoods-labels',
				type: 'symbol',
				source: 'toronto_neighborhoods_centroids',
				layout: {
					'text-field': ['get', 'area_name'],
					'text-size': ['interpolate', ['exponential', 1.1], ['zoom'], 10, 1, 18, 50],
					'text-font': ['montserrat-semibold'],
					'text-max-width': 5,
					'text-line-height': 1,
					'text-allow-overlap': true,
					'text-ignore-placement': true,
					//'text-variable-anchor': ['top', 'bottom', 'left', 'right'],
					'text-rotation-alignment': 'viewport',
					'text-pitch-alignment': 'viewport'
				},
				paint: {
					'text-color': 'hsl(225, 89%, 90%)',
					'text-opacity': ['interpolate', ['linear'], ['zoom'], 11, 0, 12, 0.8, 14, 0.8, 16, 0]
				},
				"minzoom": 11,
				"maxzoom": 16
			});

			// Add event points
			map.addLayer({
				id: 'points',
				type: 'circle',
				source: 'events',
				filter: ['!', ['has', 'point_count']],
				paint: {
					'circle-radius': 8,
					'circle-color': 'hsl(225, 89%, 90%)',
					'circle-stroke-width': 1.5,
					'circle-stroke-color': 'hsl(0, 0%, 20%)'
				}
			});

			// Add cluster circles
			map.addLayer({
				id: 'clusters',
				type: 'circle',
				source: 'events',
				filter: ['has', 'point_count'],
				paint: {
					'circle-color': [
						'step',
						['get', 'point_count'],
						'hsl(225, 89%, 90%)',
						10, 'hsl(225, 89%, 90%)',
						25, 'hsl(225, 89%, 90%)'
					],
					'circle-radius': [
						'step',
						['get', 'point_count'],
						15,
						10, 20,
						25, 25
					],
					'circle-stroke-width': 1.5,
					'circle-stroke-color': 'hsl(0, 0%, 20%)',
				},
				'maxzoom': zoomThreshold + 1
			});

			// Add cluster count
			map.addLayer({
				id: 'cluster-count',
				type: 'symbol',
				source: 'events',
				filter: ['has', 'point_count'],
				layout: {
					'text-field': '{point_count_abbreviated}',
					'text-font': ['montserrat-semibold'],
					'text-size': 16,
					'text-allow-overlap': true,
					'text-ignore-placement': true
				},
				paint: {
					'text-color': 'hsl(0, 0%, 20%)'
				},
				'maxzoom': zoomThreshold + 1
			});

			map.setLight({
				'anchor': 'viewport',
				'color': 'hsl(0, 0%, 100%)',
				'intensity': 0.5,
				'position': [1.15, 210, 20]
			});

			// Add pointer cursor for both points and clusters on hover
			map.on('mouseenter', ['points', 'clusters'], () => {
				map.getCanvas().style.cursor = 'pointer';
			});

			// Reset cursor when mouse leaves
			map.on('mouseleave', ['points', 'clusters'], () => {
				map.getCanvas().style.cursor = '';
			});

			map.once('idle', () => {
				updateInfoBox();
			});

		});

		const updateInfoBox = async () => {
			const infoBox = document.getElementById('info-box');
			infoBox.innerHTML = '';

			if (!locationData?.features?.length) return;

			// 1. Group features by unique calendar days
			const featuresByDay = locationData.features.reduce((acc, feature) => {
				if (!feature.properties.start_date) return acc;
				
				const dayKey = new Intl.DateTimeFormat('en-CA', {
					timeZone: 'America/New_York',
					year: 'numeric',
					month: '2-digit',
					day: '2-digit'
				}).format(new Date(feature.properties.start_date));

				if (!acc[dayKey]) {
					acc[dayKey] = {
						dateObj: new Date(feature.properties.start_date),
						features: []
					};
				}
				acc[dayKey].features.push(feature);
				return acc;
			}, {});

			// 2. Sort days chronologically
			const sortedDays = Object.entries(featuresByDay)
				.sort((a, b) => a[1].dateObj - b[1].dateObj);

			// 3. Create container
			const innerContainer = document.createElement('div');
			innerContainer.className = 'info-box-inner';

			// 4. Create day buttons with vertical date layout
			sortedDays.forEach(([dayKey, dayData]) => {
				const dateElement = document.createElement('div');
				dateElement.className = 'info-feature';
				if (currentActiveCategory === dayKey) {
					dateElement.classList.add('active');
				}

				// Create month element
				const monthElement = document.createElement('div');
				monthElement.className = 'info-feature-month';
				monthElement.textContent = new Intl.DateTimeFormat('en-US', {
					month: 'short'
				}).format(dayData.dateObj);

				// Create day element
				const dayElement = document.createElement('div');
				dayElement.className = 'info-feature-day';
				dayElement.textContent = new Intl.DateTimeFormat('en-US', {
					day: 'numeric'
				}).format(dayData.dateObj);

				// Append month and day
				dateElement.appendChild(monthElement);
				dateElement.appendChild(dayElement);

				dateElement.addEventListener('click', () => {
					// Toggle active state
					const isActive = dateElement.classList.contains('active');
					
					// Remove active class from all buttons
					document.querySelectorAll('.info-feature').forEach(btn => {
						btn.classList.remove('active');
					});
					
					// Toggle current button and update data
					if (isActive) {
						currentActiveCategory = 'all';
						map.getSource('events').setData(locationData);
					} else {
						dateElement.classList.add('active');
						currentActiveCategory = dayKey;
						map.getSource('events').setData({
							...locationData,
							features: dayData.features
						});
					}
				});

				innerContainer.appendChild(dateElement);
			});

			infoBox.appendChild(innerContainer);
		};

		// This is needed to allow other clicks!
		let ignoreNextMapClick = false;

		// Handle clicks on points
		map.on('click', 'points', (e) => {
			const feature = e.features[0];
			const properties = feature.properties;
			const popupContainer = document.getElementById('popup-container');
			if (!popupContainer) return;

			ignoreNextMapClick = true;
			popupContainer.innerHTML = '';

			const popupContent = document.createElement('div');
			popupContent.className = 'popup-content';

			// Create flex container
			const flexContainer = document.createElement('div');
			flexContainer.className = 'popup-flex-container';

			// Make container clickable
			if (properties.url) {
				flexContainer.addEventListener('click', () => {
					window.open(properties.url, '_blank'); // Open in new tab
					// Alternatively: window.location.href = properties.url;
				});
			}

			// Add image div (left side)
			// const imgContainer = document.createElement('div');
			// imgContainer.className = 'popup-img-container';
			// const img = document.createElement('img');
			// img.src = properties.cover || 'default-image.jpg';
			// imgContainer.appendChild(img);
			// flexContainer.appendChild(imgContainer);

			// Add date div (left side)
			const dateContainer = document.createElement('div');
			dateContainer.className = 'popup-date-container'; // New class for styling

			// Create month element
			const monthElement = document.createElement('div');
			monthElement.className = 'popup-month';
			monthElement.textContent = new Date(properties.start_date).toLocaleString('default', { month: 'short' }).toUpperCase();

			// Create day element
			const dayElement = document.createElement('div');
			dayElement.className = 'popup-day';
			dayElement.textContent = new Date(properties.start_date).getDate();

			// Append elements to date container
			dateContainer.appendChild(monthElement);
			dateContainer.appendChild(dayElement);

			// Add date container to flex container
			flexContainer.appendChild(dateContainer);

			// Add text div (right side)
			const textContainer = document.createElement('div');
			textContainer.className = 'popup-text-container';

			const title = document.createElement('h1');
			title.className = 'popup-title';
			title.textContent = properties.title || 'Untitled Location';
			textContainer.appendChild(title);

			// Time container creation
			if (properties.start_date) {
				const timeContainer = document.createElement('div');
				timeContainer.className = 'popup-time-container';

				// Clock icon
				const clockIcon = document.createElement('i');
				clockIcon.className = 'fas fa-clock popup-time-icon';

				// Time text
				const timeRange = document.createElement('span');  // Changed from <p> to <span>
				timeRange.className = 'popup-time-text';

				const formatTime = (dateString) => {
					return new Date(dateString).toLocaleTimeString('en-US', {
						hour: 'numeric',
						minute: '2-digit',
						hour12: true
					}).replace(/^0/, '');
				};

				let timeText = formatTime(properties.start_date);
				if (properties.end_date && new Date(properties.start_date).getTime() !== new Date(properties.end_date).getTime()) {
					timeText += ` – ${formatTime(properties.end_date)}`;
				}

				timeRange.textContent = timeText;

				timeContainer.appendChild(clockIcon);
				timeContainer.appendChild(timeRange);
				textContainer.appendChild(timeContainer);
			}

			// Address container creation
			if (properties.address) {
				const addressContainer = document.createElement('div');
				addressContainer.className = 'popup-address-container';

				// Location icon
				const locationIcon = document.createElement('i');
				locationIcon.className = 'fas fa-map-marker-alt popup-location-icon';

				// Address text
				const addressText = document.createElement('span');
				addressText.className = 'popup-address-text';
				addressText.textContent = properties.address;

				addressContainer.appendChild(locationIcon);
				addressContainer.appendChild(addressText);
				textContainer.appendChild(addressContainer);
			}

			if (properties.description) {
				const desc = document.createElement('p');
				desc.className = 'popup-description';
				desc.textContent = properties.description;
				textContainer.appendChild(desc);
			}

			// Assemble content
			flexContainer.appendChild(textContainer);
			popupContent.appendChild(flexContainer);
			popupContainer.appendChild(popupContent);
			popupContainer.classList.add('active');

			popupOpen = true;
			clickFeature(feature);

		});

		// Handle clicks on clusters
		map.on('click', 'clusters', (e) => {
			// Get the clicked cluster feature
			const cluster = e.features[0];
			const ids = cluster.properties.featureIds
			const features = locationData.features;

			let featureIdsArray = [];

			if (ids) {
				featureIdsArray = ids.split('|').filter(id => id !== '');
			}

			const popupContainer = document.getElementById('popup-container');
			if (!popupContainer) return;

			ignoreNextMapClick = true;
			popupContainer.innerHTML = '';

			const popupContent = document.createElement('div');
			popupContent.className = 'popup-content';

			// Get all features and sort them by start_date
			const sortedFeatures = featureIdsArray
				.map(id => features.find(f => f.api_id === id || f.properties?.api_id === id))
				.filter(Boolean) // Remove any undefined results
				.sort((a, b) => {
					// Convert dates to timestamps for comparison
					const dateA = new Date(a.properties.start_date).getTime();
					const dateB = new Date(b.properties.start_date).getTime();
					return dateA - dateB; // For ascending order (oldest first)
					// return dateB - dateA; // For descending order (newest first)
				});

			// Log descriptions for each feature ID
			sortedFeatures.forEach(feature => {
				const properties = feature.properties;

				// Create flex container
				const flexContainer = document.createElement('div');
				flexContainer.className = 'popup-flex-container';

				// Make container clickable
				if (properties.url) {
					flexContainer.addEventListener('click', () => {
						window.open(properties.url, '_blank'); // Open in new tab
						// Alternatively: window.location.href = properties.url;
					});
				}

				// Add image div (left side)
				// const imgContainer = document.createElement('div');
				// imgContainer.className = 'popup-img-container';
				// const img = document.createElement('img');
				// img.src = properties.cover || 'default-image.jpg';
				// imgContainer.appendChild(img);
				// flexContainer.appendChild(imgContainer);

				// Add date div (left side)
				const dateContainer = document.createElement('div');
				dateContainer.className = 'popup-date-container'; // New class for styling

				// Create month element
				const monthElement = document.createElement('div');
				monthElement.className = 'popup-month';
				monthElement.textContent = new Date(properties.start_date).toLocaleString('default', { month: 'short' }).toUpperCase();

				// Create day element
				const dayElement = document.createElement('div');
				dayElement.className = 'popup-day';
				dayElement.textContent = new Date(properties.start_date).getDate();

				// Append elements to date container
				dateContainer.appendChild(monthElement);
				dateContainer.appendChild(dayElement);

				// Add date container to flex container
				flexContainer.appendChild(dateContainer);

				// Add text div (right side)
				const textContainer = document.createElement('div');
				textContainer.className = 'popup-text-container';

				const title = document.createElement('h1');
				title.className = 'popup-title';
				title.textContent = properties.title || 'Untitled Location';
				textContainer.appendChild(title);

				// Time container creation
				if (properties.start_date) {
					const timeContainer = document.createElement('div');
					timeContainer.className = 'popup-time-container';

					// Clock icon
					const clockIcon = document.createElement('i');
					clockIcon.className = 'fas fa-clock popup-time-icon';

					// Time text
					const timeRange = document.createElement('span');  // Changed from <p> to <span>
					timeRange.className = 'popup-time-text';

					const formatTime = (dateString) => {
						return new Date(dateString).toLocaleTimeString('en-US', {
							hour: 'numeric',
							minute: '2-digit',
							hour12: true
						}).replace(/^0/, '');
					};

					let timeText = formatTime(properties.start_date);
					if (properties.end_date && new Date(properties.start_date).getTime() !== new Date(properties.end_date).getTime()) {
						timeText += ` – ${formatTime(properties.end_date)}`;
					}

					timeRange.textContent = timeText;

					timeContainer.appendChild(clockIcon);
					timeContainer.appendChild(timeRange);
					textContainer.appendChild(timeContainer);
				}

				// Address container creation
				if (properties.address) {
					const addressContainer = document.createElement('div');
					addressContainer.className = 'popup-address-container';

					// Location icon
					const locationIcon = document.createElement('i');
					locationIcon.className = 'fas fa-map-marker-alt popup-location-icon';

					// Address text
					const addressText = document.createElement('span');
					addressText.className = 'popup-address-text';
					addressText.textContent = properties.address;

					addressContainer.appendChild(locationIcon);
					addressContainer.appendChild(addressText);
					textContainer.appendChild(addressContainer);
				}

				if (properties.description) {
					const desc = document.createElement('p');
					desc.className = 'popup-description';
					desc.textContent = properties.description;
					textContainer.appendChild(desc);
				}

				// Assemble content
				flexContainer.appendChild(textContainer);
				popupContent.appendChild(flexContainer);
			});

			popupContainer.appendChild(popupContent);
			popupContainer.classList.add('active');

			// Scroll to top
			setTimeout(() => {
				popupContent.scrollTo({
					top: 0,
					behavior: 'smooth'
				});
			}, 50);

			popupOpen = true;
			clickCluster(cluster);

		});

		// 1. Keep your existing map click handler for non-feature clicks
		map.on('click', (e) => {
			if (!popupOpen) return;
			if (ignoreNextMapClick) {
				ignoreNextMapClick = false;
				return;
			}

			const features = map.queryRenderedFeatures(e.point, {
				layers: ['points']
			});

			if (features.length === 0) {
				closePopup();
			}
		});

		// 2. Add separate click handler for info-feature buttons
		document.addEventListener('click', (e) => {
			if (!popupOpen) return;
			
			// Check if clicked element or any of its parents is an info-feature
			const infoFeature = e.target.closest('.info-feature');
			if (infoFeature) {
				closePopup();
			}
		});

		// 3. Unified close function
		function closePopup() {
			const popupContainer = document.getElementById('popup-container');
			if (popupContainer) {
				popupContainer.classList.remove('active');
				popupOpen = false;
				map.setPaintProperty('points', 'circle-color', 'hsl(225, 89%, 90%)');
				map.setPaintProperty('clusters', 'circle-color', 'hsl(225, 89%, 90%)');
			}
		}

		// Helper function to handle clicks on points
		const clickFeature = (feature) => {
			let coordinates = feature.geometry.coordinates;
			let id = feature.properties.api_id;

			try {

				// Fly to location
				flyToFeature(coordinates);

				// Set all clusters to default style
				map.setPaintProperty('clusters', 'circle-color', 'hsl(225, 89%, 90%)');

				// Active color
				map.setPaintProperty('points', 'circle-color', [
					'case',
					['==', ['get', 'api_id'], id],
					'hsl(52, 96%, 66%)',
					'hsl(225, 89%, 90%)'
				]);

			} catch (error) {
				console.error('Error handling feature click:', error);
			}
		};

		const clickCluster = (feature) => {
			let coordinates = feature.geometry.coordinates;
			let id = feature.properties.cluster_id;

			try {

				// Fly to location
				flyToFeature(coordinates);

				// Set all features to default style first
				map.setPaintProperty('points', 'circle-color', 'hsl(225, 89%, 90%)');

				// Active color
				map.setPaintProperty('clusters', 'circle-color', [
					'case',
					['==', ['get', 'cluster_id'], id],
					'hsl(52, 96%, 66%)',
					'hsl(225, 89%, 90%)'
				]);

			} catch (error) {
				console.error('Error handling feature click:', error);
			}
		};

		// Helper function to fly to feature
		const flyToFeature = (coordinates) => {
			return new Promise((resolve) => {

				// Calculate dynamic offset based on viewport height
				const viewportHeight = window.innerHeight;
				const isMobile = window.innerWidth <= 768; // Common mobile breakpoint
				const offsetY = isMobile ? -viewportHeight * 0.15 : -80; // Adjust percentage as needed

				map.easeTo({
					center: coordinates,
					//zoom: zoomThreshold - 2,
					offset: [0, offsetY],
					essential: true
				});

				map.once('moveend', resolve);
			});
		};

		// Add attribution
		map.on('load', () => {
			const attribControl = document.querySelector('.maplibregl-ctrl-attrib-inner');
			if (attribControl) {
				attribControl.innerHTML = `<a href="https://www.openstreetmap.org/copyright">© OpenStreetMap</a> | <a href="https://www.torontotechweek.com/" target="_blank">Toronto Tech Week</a> | <a href="https://geographyclub.github.io/" target="_blank">J&S</a>`;
			}
		});

	</script>
</body>

</html>